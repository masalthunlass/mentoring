# How to start a new project
* create a react app 
* from scratch

# creating new project from scratch 14092020
* npm needed
* npm init
* npm install 
    ** wepback, webpack-cli, 
    ** babel (loader, preset, preset-react, core), 
    ** typescript-preset, 
    ** react, react-dom, @types/react, @types/react-dom
* configure presets in babel.config.json
* configure webpack (alternatives gulp makefiles / parcel / rollup) = bundlers
* add an index.html at root level and add at least a div with an id and  a script tag pointing to the bundle file 
* add a dist (distribution) directory at root level for the bundle (it must be set in webpack.config.js)
* in package.json add a build script with "webpack" command in it
* add an index.tsx (tsx and jsx accept html tags) in a src directory
* import react and reactdom in index.tsx and call render() method to add a first element in index.html
* npm run build then press go live to see the result in a browser at http://127.0.0.1:5500/

# creating a component

## from a function
* create a tsx file named App.tsx
* write a function App returning a block of html tags (the return type is React.FC)
* export it
* use it in the render() function in index.tsx or anywhere else as a tag <App>

## from a class
* create a tsx file named Item.tsx
* write a class Item extending  React.Component
* make its render function returning a block of html tags 
* export it
* use it in the render() function in index.tsx or anywhere else as a tag <Item>

components made from classes have lifecycle, those made from functions haven't.

# component lifecycle

## mounting lifecycle (=inserting into the dom tree)
1. constructor() => 
    * use it to init the local state or bind some event handlers to the instance
    * ! always call 'super(props)' before using 'this' 
    * ! never call "setState', use this.state instead 
      (! and it is the only place where you should not use the former than the latter )
    * ! never copy props in local state 
2. static getDerivedStateFromProps() => rarely used
3. render()
4. componentDidMount()
    * where to call data loading requests, add subscriptions or inits
 

## updating lifecycle
1. static getDerivedStateFromProps() => rarely used
2. shouldComponentUpdate() => rarely used / for performance optimization purpose
    * called when props or local state have been updated
    * returns true by default
    * if it returns false componentDidUpdate() will not be called
3. render()
4. getSnapshotBeforeUpdate() => rarely used
5. componentDidUpdate() => 
    * called just after the updating occurred
    * ! use setState only in a condition 

## unmounting lifecycle (=removing from the dom tree)
1. componentWillUnmount() => where to unsubscribe, clean or invalidate

## error handling lifecycle
1. static getDerivedStateFromError()
2. componentDidCatch(error, info)

# props
* components entries/data
* read only
* received from parent component

# state
* to change data of a component
* generated by the component itself

# managed component 
* = managed by react, useing virtual dom

# redux configuration
* add store (=state storage) in index.ts all 
    the app has the same store. several stores are allowed but uncommon
* type the store to make explicit what will be stored
* define actions Action = Action<string> (ex CREATE)
* actionCreators return Action
* reducers catch actions and return back a storer with an up-to-date store
* connect with components 

